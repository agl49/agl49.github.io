{"version":3,"file":"DypuxxhO.js","sources":["../../../../../../node_modules/svelte/src/internal/client/proxy.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/store.js"],"sourcesContent":["/** @import { ProxyMetadata, Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { get, active_effect } from './runtime.js';\nimport { component_context } from './context.js';\nimport {\n\tarray_prototype,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tobject_prototype\n} from '../shared/utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { source, set } from './reactivity/sources.js';\nimport { STATE_SYMBOL, STATE_SYMBOL_METADATA } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\nimport { get_stack } from './dev/tracing.js';\nimport { tracing_mode_flag } from '../flags/index.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {ProxyMetadata | null} [parent]\n * @param {Source<T>} [prev] dev mode only\n * @returns {T}\n */\nexport function proxy(value, parent = null, prev) {\n\t/** @type {Error | null} */\n\tvar stack = null;\n\tif (DEV && tracing_mode_flag) {\n\t\tstack = get_stack('CreatedAt');\n\t}\n\t// if non-proxyable, or is already a proxy, return `value`\n\tif (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {\n\t\treturn value;\n\t}\n\n\tconst prototype = get_prototype_of(value);\n\n\tif (prototype !== object_prototype && prototype !== array_prototype) {\n\t\treturn value;\n\t}\n\n\t/** @type {Map<any, Source<any>>} */\n\tvar sources = new Map();\n\tvar is_proxied_array = is_array(value);\n\tvar version = source(0);\n\n\tif (is_proxied_array) {\n\t\t// We need to create the length source eagerly to ensure that\n\t\t// mutations to the array are properly synced with our proxy\n\t\tsources.set('length', source(/** @type {any[]} */ (value).length, stack));\n\t}\n\n\t/** @type {ProxyMetadata} */\n\tvar metadata;\n\n\tif (DEV) {\n\t\tmetadata = {\n\t\t\tparent,\n\t\t\towners: null\n\t\t};\n\n\t\tif (prev) {\n\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t// @ts-expect-error\n\t\t\tconst prev_owners = prev.v?.[STATE_SYMBOL_METADATA]?.owners;\n\t\t\tmetadata.owners = prev_owners ? new Set(prev_owners) : null;\n\t\t} else {\n\t\t\tmetadata.owners =\n\t\t\t\tparent === null\n\t\t\t\t\t? component_context !== null\n\t\t\t\t\t\t? new Set([component_context.function])\n\t\t\t\t\t\t: null\n\t\t\t\t\t: new Set();\n\t\t}\n\t}\n\n\treturn new Proxy(/** @type {any} */ (value), {\n\t\tdefineProperty(_, prop, descriptor) {\n\t\t\tif (\n\t\t\t\t!('value' in descriptor) ||\n\t\t\t\tdescriptor.configurable === false ||\n\t\t\t\tdescriptor.enumerable === false ||\n\t\t\t\tdescriptor.writable === false\n\t\t\t) {\n\t\t\t\t// we disallow non-basic descriptors, because unless they are applied to the\n\t\t\t\t// target object — which we avoid, so that state can be forked — we will run\n\t\t\t\t// afoul of the various invariants\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants\n\t\t\t\te.state_descriptors_fixed();\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\ts = source(descriptor.value, stack);\n\t\t\t\tsources.set(prop, s);\n\t\t\t} else {\n\t\t\t\tset(s, proxy(descriptor.value, metadata));\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tdeleteProperty(target, prop) {\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\tif (prop in target) {\n\t\t\t\t\tsources.set(prop, source(UNINITIALIZED, stack));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// When working with arrays, we need to also ensure we update the length when removing\n\t\t\t\t// an indexed property\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n < ls.v) {\n\t\t\t\t\t\tset(ls, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset(s, UNINITIALIZED);\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tget(target, prop, receiver) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn metadata;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\t// create a source, but only if it's an own property and not a prototype property\n\t\t\tif (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {\n\t\t\t\ts = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata), stack);\n\t\t\t\tsources.set(prop, s);\n\t\t\t}\n\n\t\t\tif (s !== undefined) {\n\t\t\t\tvar v = get(s);\n\n\t\t\t\t// In case of something like `foo = bar.map(...)`, foo would have ownership\n\t\t\t\t// of the array itself, while the individual items would have ownership\n\t\t\t\t// of the component that created bar. That means if we later do `foo[0].baz = 42`,\n\t\t\t\t// we could get a false-positive ownership violation, since the two proxies\n\t\t\t\t// are not connected to each other via the parent metadata relationship.\n\t\t\t\t// For this reason, we need to widen the ownership of the children\n\t\t\t\t// upon access when we detect they are not connected.\n\t\t\t\tif (DEV) {\n\t\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\t\tvar prop_metadata = v?.[STATE_SYMBOL_METADATA];\n\t\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn v === UNINITIALIZED ? undefined : v;\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t\tvar s = sources.get(prop);\n\t\t\t\tif (s) descriptor.value = get(s);\n\t\t\t} else if (descriptor === undefined) {\n\t\t\t\tvar source = sources.get(prop);\n\t\t\t\tvar value = source?.v;\n\n\t\t\t\tif (source !== undefined && value !== UNINITIALIZED) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn descriptor;\n\t\t},\n\n\t\thas(target, prop) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);\n\n\t\t\tif (\n\t\t\t\ts !== undefined ||\n\t\t\t\t(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t\t) {\n\t\t\t\tif (s === undefined) {\n\t\t\t\t\ts = source(has ? proxy(target[prop], metadata) : UNINITIALIZED, stack);\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\n\t\t\t\tvar value = get(s);\n\t\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn has;\n\t\t},\n\n\t\tset(target, prop, value, receiver) {\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = prop in target;\n\n\t\t\t// variable.length = value -> clear all signals with index >= value\n\t\t\tif (is_proxied_array && prop === 'length') {\n\t\t\t\tfor (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {\n\t\t\t\t\tvar other_s = sources.get(i + '');\n\t\t\t\t\tif (other_s !== undefined) {\n\t\t\t\t\t\tset(other_s, UNINITIALIZED);\n\t\t\t\t\t} else if (i in target) {\n\t\t\t\t\t\t// If the item exists in the original, we need to create a uninitialized source,\n\t\t\t\t\t\t// else a later read of the property would result in a source being created with\n\t\t\t\t\t\t// the value of the original item at that index.\n\t\t\t\t\t\tother_s = source(UNINITIALIZED, stack);\n\t\t\t\t\t\tsources.set(i + '', other_s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t\t// object property before writing to that property.\n\t\t\tif (s === undefined) {\n\t\t\t\tif (!has || get_descriptor(target, prop)?.writable) {\n\t\t\t\t\ts = source(undefined, stack);\n\t\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thas = s.v !== UNINITIALIZED;\n\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t}\n\n\t\t\tif (DEV) {\n\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\tvar prop_metadata = value?.[STATE_SYMBOL_METADATA];\n\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t}\n\t\t\t\tcheck_ownership(metadata);\n\t\t\t}\n\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t\tif (descriptor?.set) {\n\t\t\t\tdescriptor.set.call(receiver, value);\n\t\t\t}\n\n\t\t\tif (!has) {\n\t\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t\t// will not cause the length to be out of sync.\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n >= ls.v) {\n\t\t\t\t\t\tset(ls, n + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\townKeys(target) {\n\t\t\tget(version);\n\n\t\t\tvar own_keys = Reflect.ownKeys(target).filter((key) => {\n\t\t\t\tvar source = sources.get(key);\n\t\t\t\treturn source === undefined || source.v !== UNINITIALIZED;\n\t\t\t});\n\n\t\t\tfor (var [key, source] of sources) {\n\t\t\t\tif (source.v !== UNINITIALIZED && !(key in target)) {\n\t\t\t\t\town_keys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn own_keys;\n\t\t},\n\n\t\tsetPrototypeOf() {\n\t\t\te.state_prototype_fixed();\n\t\t}\n\t});\n}\n\n/**\n * @param {Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\treturn value[STATE_SYMBOL];\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n"],"names":["proxy","value","parent","prev","STATE_SYMBOL","prototype","get_prototype_of","object_prototype","array_prototype","sources","is_proxied_array","is_array","version","source","metadata","_","prop","descriptor","e.state_descriptors_fixed","s","set","target","UNINITIALIZED","ls","n","update_version","receiver","exists","_a","get_descriptor","v","get","has","active_effect","i","other_s","own_keys","key","e.state_prototype_fixed","signal","d","is_store_binding","IS_UNMOUNTED","store_get","store","store_name","stores","entry","mutable_source","noop","is_synchronous_callback","subscribe_to_store","get_store","store_set","setup_stores","cleanup","teardown","define_property","capture_store_binding","fn","previous_is_store_binding"],"mappings":"6LA0BO,SAASA,EAAMC,EAAOC,EAAS,KAAMC,EAAM,CAOjD,GAAI,OAAOF,GAAU,UAAYA,IAAU,MAAQG,KAAgBH,EAClE,OAAOA,EAGR,MAAMI,EAAYC,EAAiBL,CAAK,EAExC,GAAII,IAAcE,GAAoBF,IAAcG,EACnD,OAAOP,EAIR,IAAIQ,EAAU,IAAI,IACdC,EAAmBC,EAASV,CAAK,EACjCW,EAAUC,EAAO,CAAC,EAElBH,GAGHD,EAAQ,IAAI,SAAUI,EAA6BZ,EAAO,MAAa,CAAC,EAIzE,IAAIa,EAwBJ,OAAO,IAAI,MAA0Bb,EAAQ,CAC5C,eAAec,EAAGC,EAAMC,EAAY,EAElC,EAAE,UAAWA,IACbA,EAAW,eAAiB,IAC5BA,EAAW,aAAe,IAC1BA,EAAW,WAAa,KAMxBC,EAA2B,EAG5B,IAAIC,EAAIV,EAAQ,IAAIO,CAAI,EAExB,OAAIG,IAAM,QACTA,EAAIN,EAAOI,EAAW,KAAY,EAClCR,EAAQ,IAAIO,EAAMG,CAAC,GAEnBC,EAAID,EAAGnB,EAAMiB,EAAW,MAAOH,CAAQ,CAAC,EAGlC,EACP,EAED,eAAeO,EAAQL,EAAM,CAC5B,IAAIG,EAAIV,EAAQ,IAAIO,CAAI,EAExB,GAAIG,IAAM,OACLH,KAAQK,GACXZ,EAAQ,IAAIO,EAAMH,EAAOS,CAAoB,CAAC,MAEzC,CAGN,GAAIZ,GAAoB,OAAOM,GAAS,SAAU,CACjD,IAAIO,EAAoCd,EAAQ,IAAI,QAAQ,EACxDe,EAAI,OAAOR,CAAI,EAEf,OAAO,UAAUQ,CAAC,GAAKA,EAAID,EAAG,GACjCH,EAAIG,EAAIC,CAAC,CAEf,CACIJ,EAAID,EAAGG,CAAa,EACpBG,EAAeb,CAAO,CAC1B,CAEG,MAAO,EACP,EAED,IAAIS,EAAQL,EAAMU,EAAU,OAK3B,GAAIV,IAASZ,EACZ,OAAOH,EAGR,IAAIkB,EAAIV,EAAQ,IAAIO,CAAI,EACpBW,EAASX,KAAQK,EAQrB,GALIF,IAAM,SAAc,CAACQ,IAAUC,EAAAC,EAAeR,EAAQL,CAAI,IAA3B,MAAAY,EAA8B,YAChET,EAAIN,EAAOb,EAAM2B,EAASN,EAAOL,CAAI,EAAIM,EAAeR,CAAQ,CAAQ,EACxEL,EAAQ,IAAIO,EAAMG,CAAC,GAGhBA,IAAM,OAAW,CACpB,IAAIW,EAAIC,EAAIZ,CAAC,EAiBb,OAAOW,IAAMR,EAAgB,OAAYQ,CAC7C,CAEG,OAAO,QAAQ,IAAIT,EAAQL,EAAMU,CAAQ,CACzC,EAED,yBAAyBL,EAAQL,EAAM,CACtC,IAAIC,EAAa,QAAQ,yBAAyBI,EAAQL,CAAI,EAE9D,GAAIC,GAAc,UAAWA,EAAY,CACxC,IAAIE,EAAIV,EAAQ,IAAIO,CAAI,EACpBG,IAAGF,EAAW,MAAQc,EAAIZ,CAAC,EACnC,SAAcF,IAAe,OAAW,CACpC,IAAIJ,EAASJ,EAAQ,IAAIO,CAAI,EACzBf,EAAQY,GAAA,YAAAA,EAAQ,EAEpB,GAAIA,IAAW,QAAaZ,IAAUqB,EACrC,MAAO,CACN,WAAY,GACZ,aAAc,GACd,MAAArB,EACA,SAAU,EACV,CAEN,CAEG,OAAOgB,CACP,EAED,IAAII,EAAQL,EAAM,OAKjB,GAAIA,IAASZ,EACZ,MAAO,GAGR,IAAIe,EAAIV,EAAQ,IAAIO,CAAI,EACpBgB,EAAOb,IAAM,QAAaA,EAAE,IAAMG,GAAkB,QAAQ,IAAID,EAAQL,CAAI,EAEhF,GACCG,IAAM,QACLc,IAAkB,OAAS,CAACD,IAAOJ,EAAAC,EAAeR,EAAQL,CAAI,IAA3B,MAAAY,EAA8B,UACjE,CACGT,IAAM,SACTA,EAAIN,EAAOmB,EAAMhC,EAAMqB,EAAOL,CAAI,EAAGF,CAAQ,EAAIQ,CAAoB,EACrEb,EAAQ,IAAIO,EAAMG,CAAC,GAGpB,IAAIlB,EAAQ8B,EAAIZ,CAAC,EACjB,GAAIlB,IAAUqB,EACb,MAAO,EAEZ,CAEG,OAAOU,CACP,EAED,IAAIX,EAAQL,EAAMf,EAAOyB,EAAU,OAClC,IAAIP,EAAIV,EAAQ,IAAIO,CAAI,EACpBgB,EAAMhB,KAAQK,EAGlB,GAAIX,GAAoBM,IAAS,SAChC,QAASkB,EAAIjC,EAAOiC,EAAmCf,EAAG,EAAGe,GAAK,EAAG,CACpE,IAAIC,EAAU1B,EAAQ,IAAIyB,EAAI,EAAE,EAC5BC,IAAY,OACff,EAAIe,EAASb,CAAa,EAChBY,KAAKb,IAIfc,EAAUtB,EAAOS,CAAoB,EACrCb,EAAQ,IAAIyB,EAAI,GAAIC,CAAO,EAEjC,CAOOhB,IAAM,QACL,CAACa,IAAOJ,EAAAC,EAAeR,EAAQL,CAAI,IAA3B,MAAAY,EAA8B,YACzCT,EAAIN,EAAO,MAAgB,EAC3BO,EAAID,EAAGnB,EAAMC,EAAOa,CAAQ,CAAC,EAC7BL,EAAQ,IAAIO,EAAMG,CAAC,IAGpBa,EAAMb,EAAE,IAAMG,EACdF,EAAID,EAAGnB,EAAMC,EAAOa,CAAQ,CAAC,GAY9B,IAAIG,EAAa,QAAQ,yBAAyBI,EAAQL,CAAI,EAO9D,GAJIC,GAAA,MAAAA,EAAY,KACfA,EAAW,IAAI,KAAKS,EAAUzB,CAAK,EAGhC,CAAC+B,EAAK,CAKT,GAAItB,GAAoB,OAAOM,GAAS,SAAU,CACjD,IAAIO,EAAoCd,EAAQ,IAAI,QAAQ,EACxDe,EAAI,OAAOR,CAAI,EAEf,OAAO,UAAUQ,CAAC,GAAKA,GAAKD,EAAG,GAClCH,EAAIG,EAAIC,EAAI,CAAC,CAEnB,CAEIC,EAAeb,CAAO,CAC1B,CAEG,MAAO,EACP,EAED,QAAQS,EAAQ,CACfU,EAAInB,CAAO,EAEX,IAAIwB,EAAW,QAAQ,QAAQf,CAAM,EAAE,OAAQgB,GAAQ,CACtD,IAAIxB,EAASJ,EAAQ,IAAI4B,CAAG,EAC5B,OAAOxB,IAAW,QAAaA,EAAO,IAAMS,CAChD,CAAI,EAED,OAAS,CAACe,EAAKxB,CAAM,IAAKJ,EACrBI,EAAO,IAAMS,GAAiB,EAAEe,KAAOhB,IAC1Ce,EAAS,KAAKC,CAAG,EAInB,OAAOD,CACP,EAED,gBAAiB,CAChBE,EAAyB,CAC5B,CACA,CAAE,CACF,CAMA,SAASb,EAAec,EAAQC,EAAI,EAAG,CACtCpB,EAAImB,EAAQA,EAAO,EAAIC,CAAC,CACzB,CCxTA,IAAIC,EAAmB,GAEnBC,EAAe,OAAQ,EAYpB,SAASC,EAAUC,EAAOC,EAAYC,EAAQ,CACpD,MAAMC,EAASD,EAAAD,KAAAC,EAAAD,GAAuB,CACrC,MAAO,KACP,OAAQG,EAAe,MAAS,EAChC,YAAaC,CACf,GAGC,GAAIF,EAAM,QAAUH,GAAS,EAAEF,KAAgBI,GAI9C,GAHAC,EAAM,YAAa,EACnBA,EAAM,MAAQH,GAAS,KAEnBA,GAAS,KACZG,EAAM,OAAO,EAAI,OACjBA,EAAM,YAAcE,MACd,CACN,IAAIC,EAA0B,GAE9BH,EAAM,YAAcI,EAAmBP,EAAQd,GAAM,CAChDoB,EAGHH,EAAM,OAAO,EAAIjB,EAEjBV,EAAI2B,EAAM,OAAQjB,CAAC,CAExB,CAAI,EAEDoB,EAA0B,EAC7B,CAMC,OAAIN,GAASF,KAAgBI,EACrBM,EAAUR,CAAK,EAGhBb,EAAIgB,EAAM,MAAM,CACxB,CA8BO,SAASM,EAAUT,EAAO3C,EAAO,CACvC,OAAA2C,EAAM,IAAI3C,CAAK,EACRA,CACR,CAiBO,SAASqD,GAAe,CAE9B,MAAMR,EAAS,CAAE,EAEjB,SAASS,GAAU,CAClBC,EAAS,IAAM,CACd,QAASX,KAAcC,EACVA,EAAOD,CAAU,EACzB,YAAa,EAElBY,EAAgBX,EAAQJ,EAAc,CACrC,WAAY,GACZ,MAAO,EACX,CAAI,CACJ,CAAG,CACH,CAEC,MAAO,CAACI,EAAQS,CAAO,CACxB,CAoDO,SAASG,EAAsBC,EAAI,CACzC,IAAIC,EAA4BnB,EAEhC,GAAI,CACH,OAAAA,EAAmB,GACZ,CAACkB,EAAI,EAAElB,CAAgB,CAChC,QAAW,CACTA,EAAmBmB,CACrB,CACA","x_google_ignoreList":[0,1]}